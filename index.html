<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nuke Em - Deep Fry Your Memes</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    @keyframes slide-in {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .animate-slide-in {
      animation: slide-in 0.3s ease-out;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    const getContext = (canvas) => {
      const ctx = canvas.getContext('2d');
      // Disable smoothing for sharp pixels
      ctx.imageSmoothingEnabled = false;
      ctx.mozImageSmoothingEnabled = false;
      ctx.webkitImageSmoothingEnabled = false;
      ctx.msImageSmoothingEnabled = false;
      return ctx;
    };
    


    const NukeMemes = () => {
      const [currentImage, setCurrentImage] = useState(null);
      const [nukeCount, setNukeCount] = useState(0);
      const [history, setHistory] = useState([]);
      const [lastEffects, setLastEffects] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [toast, setToast] = useState({ show: false, message: '', type: '' });
      const canvasRef = useRef(null);
      const fileInputRef = useRef(null);
      const [showPasswordModal, setShowPasswordModal] = useState(false);
      const [showRestoreModal, setShowRestoreModal] = useState(false);
      const [password, setPassword] = useState('');
      const [exportMode, setExportMode] = useState('normal'); // 'normal' or 'protected'
      const [hasProtectedData, setHasProtectedData] = useState(false);
      const [showPassword, setShowPassword] = useState(false);
      const [lastTypedIndex, setLastTypedIndex] = useState(-1);

        useEffect(() => {
          if (currentImage && canvasRef.current) {
            drawImageToCanvas(currentImage);
          }
        }, [currentImage]);

        const showToast = (message, type = 'success') => {
          setToast({ show: true, message, type });
          setTimeout(() => {
            setToast({ show: false, message: '', type: '' });
          }, 2000); // Auto-dismiss after 2 seconds
        };

        // Keyboard shortcuts
        useEffect(() => {
          const handleKeyPress = (e) => {
            // Don't trigger if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            
            switch(key) {
              case 'd':
                if (currentImage) nukeImage();
                break;
              case 'a':
                if (history.length > 0) undoNuke();
                break;
              case 's':
                e.preventDefault(); // Prevent browser save dialog
                if (currentImage) exportImage(false);
                break;
              case 'g':
                e.preventDefault(); // Prevent browser find
                if (currentImage) exportImage(true);
                break;
              case 'e':
                if (currentImage) applyPattern();
                break;
              case 'n':
                resetImage();
                break;
              default:
                break;
            }
          };
          
          window.addEventListener('keydown', handleKeyPress);
          
          // Cleanup
          return () => {
            window.removeEventListener('keydown', handleKeyPress);
          };
        }, [currentImage, history, password]); // Re-bind when these change

        const loadImage = (file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              setCurrentImage(img);
              setNukeCount(0);
              setHistory([]);
              setLastEffects([]);
              
              // Draw after state update
              setTimeout(() => {
                if (canvasRef.current) {
                  drawImageToCanvas(img);
                }
              }, 0);
              
              // Check if image has protected data
              setTimeout(() => {
                try {
                  const canvas = canvasRef.current;
                  const tempCanvas = document.createElement('canvas');
                  tempCanvas.width = canvas.width;
                  tempCanvas.height = canvas.height;
                  const tempCtx = tempCanvas.getContext('2d');
                  tempCtx.drawImage(canvas, 0, 0);
                  
                  // Try to read length header
                  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                  const pixels = imageData.data;
                  
                  let binaryLength = '';
                  for (let i = 0; i < 80; i++) {
                    const pixelIndex = Math.floor(i / 3) * 4;
                    const channel = i % 3;
                    binaryLength += (pixels[pixelIndex + channel] & 1).toString();
                  }
                  
                  let lengthStr = '';
                  for (let i = 0; i < binaryLength.length; i += 8) {
                    lengthStr += String.fromCharCode(parseInt(binaryLength.substr(i, 8), 2));
                  }
                  const dataLength = parseInt(lengthStr);
                  
                  // If valid length found, image has protected data
                  if (!isNaN(dataLength) && dataLength > 0 && dataLength < 10000000) {
                    setHasProtectedData(true);
                    showToast('ðŸ” Protected image detected!', 'info');
                  } else {
                    setHasProtectedData(false);
                  }
                } catch (e) {
                  setHasProtectedData(false);
                }
              }, 100);
              
              showToast(`ðŸ“¸ Image loaded: ${file.name}`, 'success');
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        };

        const drawImageToCanvas = (img) => {
          const canvas = canvasRef.current;
          if (!canvas) {
            console.error('Canvas not ready');
            return;
          }
          
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          
          // DISABLE IMAGE SMOOTHING - This is the key fix!
          ctx.imageSmoothingEnabled = false;
          ctx.mozImageSmoothingEnabled = false;
          ctx.webkitImageSmoothingEnabled = false;
          ctx.msImageSmoothingEnabled = false;
          
          ctx.drawImage(img, 0, 0);
        };

        const applyGlitchEffect = (imageData, strength) => {
          const data = imageData.data;
          const offset = Math.floor((strength / 10) * 20) + 5;
          const frequency = 0.7 + (strength / 10) * 0.15;
          
          for (let i = 0; i < data.length; i += 4) {
            if (Math.random() > frequency) {
              const shiftIndex = Math.min(i + offset * 4, data.length - 4);
              [data[i], data[shiftIndex]] = [data[shiftIndex], data[i]];
            }
          }
        };

        const applyRGBShift = (ctx, width, height, strength) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const shift = Math.floor((strength / 10) * 10) + 3;
          
          const tempData = new Uint8ClampedArray(data);
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = (y * width + x) * 4;
              const shiftedX = Math.min(x + shift, width - 1);
              const shiftedI = (y * width + shiftedX) * 4;
              
              data[i] = tempData[shiftedI];
              data[i + 2] = tempData[i + 2];
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
        };

        const applyNoise = (imageData, strength) => {
          const data = imageData.data;
          const intensity = 0.05 + (strength / 10) * 0.15;
          const range = (strength / 10) * 80;
          
          for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < intensity) {
              const noise = (Math.random() - 0.5) * range;
              data[i] = Math.max(20, Math.min(235, data[i] + noise));
              data[i + 1] = Math.max(20, Math.min(235, data[i + 1] + noise));
              data[i + 2] = Math.max(20, Math.min(235, data[i + 2] + noise));
            }
          }
        };

        const applyColorDistortion = (imageData, strength = 5) => {
          const data = imageData.data;
          const hueShift = (strength / 10) * 180;
          const satMult = 0.5 + (strength / 10) * 1.5;
          
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i] / 255;
            let g = data[i + 1] / 255;
            let b = data[i + 2] / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
              h = s = 0;
            } else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            
            h = (h * 360 + hueShift) % 360 / 360;
            s = Math.min(s * satMult, 1);
            
            const hue2rgb = (p, q, t) => {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            };
            
            if (s === 0) {
              r = g = b = l;
            } else {
              const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              const p = 2 * l - q;
              r = hue2rgb(p, q, h + 1/3);
              g = hue2rgb(p, q, h);
              b = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r * 255;
            data[i + 1] = g * 255;
            data[i + 2] = b * 255;
          }
        };

        const applyPosterize = (imageData, strength = 5) => {
          const data = imageData.data;
          const levels = Math.max(2, Math.floor(11 - (strength / 10) * 8));
          const step = 255 / levels;
          
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.floor(data[i] / step) * step;
            data[i + 1] = Math.floor(data[i + 1] / step) * step;
            data[i + 2] = Math.floor(data[i + 2] / step) * step;
          }
        };

        const applyEdgeDetection = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newData = new Uint8ClampedArray(data);
          
          const kernel = [
            [-1, -1, -1],
            [-1,  8, -1],
            [-1, -1, -1]
          ];
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              let r = 0, g = 0, b = 0;
              
              for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                  const idx = ((y + ky) * width + (x + kx)) * 4;
                  const weight = kernel[ky + 1][kx + 1];
                  r += data[idx] * weight;
                  g += data[idx + 1] * weight;
                  b += data[idx + 2] * weight;
                }
              }
              
              const i = (y * width + x) * 4;
              newData[i] = Math.abs(r);
              newData[i + 1] = Math.abs(g);
              newData[i + 2] = Math.abs(b);
            }
          }
          
          ctx.globalAlpha = 0.4;
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = width;
          tempCanvas.height = height;
          const tempCtx = tempCanvas.getContext('2d');
          const newImageData = tempCtx.createImageData(width, height);
          newImageData.data.set(newData);
          tempCtx.putImageData(newImageData, 0, 0);
          ctx.drawImage(tempCanvas, 0, 0);
          ctx.globalAlpha = 1.0;
        };

        const applyKaleidoscope = (ctx, width, height, strength = 5) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          const segments = 2 + Math.floor(Math.random() * 3);
          const centerX = width / 2;
          const centerY = height / 2;

          ctx.globalAlpha = 0.5;
          
        
          
          for (let i = 1; i < segments; i++) {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate((Math.PI * 2 / segments) * i);
            if (i % 2 === 0) {
              ctx.scale(-1, 1);
            }
            ctx.drawImage(tempCanvas, -centerX, -centerY);
            ctx.restore();
          }
          
          ctx.globalAlpha = 1.0;
        };

        const applyBlockGlitch = (ctx, width, height, strength = 5) => {
          const blockCount = Math.floor((strength / 10) * 30) + 15;
          
          for (let i = 0; i < blockCount; i++) {
            const maxWidth = Math.floor((strength / 10) * 150) + 10;
            const maxHeight = Math.floor((strength / 10) * 80) + 5;
            const blockWidth = Math.floor(Math.random() * maxWidth) + 10;
            const blockHeight = Math.floor(Math.random() * maxHeight) + 5;
            const srcX = Math.floor(Math.random() * Math.max(1, width - blockWidth));
            const srcY = Math.floor(Math.random() * Math.max(1, height - blockHeight));
            const destX = Math.floor(Math.random() * Math.max(1, width - blockWidth));
            const destY = Math.floor(Math.random() * Math.max(1, height - blockHeight));
            
            const blockData = ctx.getImageData(srcX, srcY, blockWidth, blockHeight);
            ctx.putImageData(blockData, destX, destY);
          }
        };

        const applyChromatic = (ctx, width, height, strength) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          const offset = Math.floor((strength / 10) * 15) + 3;
          
          ctx.globalCompositeOperation = 'screen';
          
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.filter = 'brightness(1.2) contrast(1.3)';
          ctx.drawImage(tempCanvas, -offset, 0);
          ctx.restore();
          
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.filter = 'brightness(0.8) contrast(1.3) hue-rotate(180deg)';
          ctx.drawImage(tempCanvas, offset, 0);
          ctx.restore();
          
          ctx.globalCompositeOperation = 'source-over';
          ctx.globalAlpha = 1.0;
        };

        const applyRadialBlur = (ctx, width, height, strength = 5) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          const centerX = width / 2;
          const centerY = height / 2;
          const blurStrength = (strength / 10) * 0.02 + 0.01; // FIXED: renamed variable
          
          ctx.globalAlpha = 0.3;
          for (let i = 0; i < 8; i++) {
            const scale = 1 + blurStrength * i;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
          }
          ctx.globalAlpha = 1.0;
        };

        const applySwirl = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const centerX = width / 2;
          const centerY = height / 2;
          const radius = Math.min(width, height) / 2;
          const angle = (strength / 10 - 0.5) * Math.PI * 2;
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const dx = x - centerX;
              const dy = y - centerY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const destIdx = (y * width + x) * 4;
              
              if (distance < radius) {
                const percent = (radius - distance) / radius;
                const rotateAngle = percent * angle;
                
                const srcX = Math.cos(rotateAngle) * dx - Math.sin(rotateAngle) * dy + centerX;
                const srcY = Math.sin(rotateAngle) * dx + Math.cos(rotateAngle) * dy + centerY;
                
                if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                  const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                  
                  newData[destIdx] = data[srcIdx];
                  newData[destIdx + 1] = data[srcIdx + 1];
                  newData[destIdx + 2] = data[srcIdx + 2];
                  newData[destIdx + 3] = 255;
                } else {
                  // Keep original pixel if swirl goes out of bounds
                  const origIdx = (y * width + x) * 4;
                  newData[destIdx] = data[origIdx];
                  newData[destIdx + 1] = data[origIdx + 1];
                  newData[destIdx + 2] = data[origIdx + 2];
                  newData[destIdx + 3] = 255;
                }
              } else {
                // Outside swirl radius - keep original pixel
                const srcIdx = (y * width + x) * 4;
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyGlass = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const scale = Math.floor((strength / 10) * 15) + 5; // Use strength
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const offsetX = Math.floor((Math.random() - 0.5) * scale * 2);
              const offsetY = Math.floor((Math.random() - 0.5) * scale * 2);
              
              const srcX = Math.max(0, Math.min(width - 1, x + offsetX));
              const srcY = Math.max(0, Math.min(height - 1, y + offsetY));
              
              const srcIdx = (srcY * width + srcX) * 4;
              const destIdx = (y * width + x) * 4;
              
              newData[destIdx] = data[srcIdx];
              newData[destIdx + 1] = data[srcIdx + 1];
              newData[destIdx + 2] = data[srcIdx + 2];
              newData[destIdx + 3] = 255;
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyBulge = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const centerX = width / 2;
          const centerY = height / 2;
          const radius = Math.min(width, height) * 0.4;
          const bulgeStrength = (strength / 10) * 0.5 + 0.3; // FIXED: renamed variable
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const dx = x - centerX;
              const dy = y - centerY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < radius) {
                const percent = distance / radius;
                const bulge = Math.sin(percent * Math.PI / 2);
                const scale = 1 - bulgeStrength * bulge;
                
                const srcX = Math.floor(centerX + dx * scale);
                const srcY = Math.floor(centerY + dy * scale);
                
                if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                  const srcIdx = (srcY * width + srcX) * 4;
                  const destIdx = (y * width + x) * 4;
                  
                  newData[destIdx] = data[srcIdx];
                  newData[destIdx + 1] = data[srcIdx + 1];
                  newData[destIdx + 2] = data[srcIdx + 2];
                  newData[destIdx + 3] = 255;
                }
              } else {
                const srcIdx = (y * width + x) * 4;
                const destIdx = (y * width + x) * 4;
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyPinch = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const centerX = width / 2;
          const centerY = height / 2;
          const radius = Math.min(width, height) * 0.4;
          const pinchStrength = (strength / 10) * 0.5 + 0.3; // FIXED: renamed variable
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const dx = x - centerX;
              const dy = y - centerY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < radius) {
                const percent = distance / radius;
                const pinch = Math.sin(percent * Math.PI / 2);
                const scale = 1 + pinchStrength * pinch;
                
                const srcX = Math.floor(centerX + dx * scale);
                const srcY = Math.floor(centerY + dy * scale);
                
                if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                  const srcIdx = (srcY * width + srcX) * 4;
                  const destIdx = (y * width + x) * 4;
                  
                  newData[destIdx] = data[srcIdx];
                  newData[destIdx + 1] = data[srcIdx + 1];
                  newData[destIdx + 2] = data[srcIdx + 2];
                  newData[destIdx + 3] = 255;
                }
              } else {
                const srcIdx = (y * width + x) * 4;
                const destIdx = (y * width + x) * 4;
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyCrystallize = (ctx, width, height, strength = 5) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          ctx.clearRect(0, 0, width, height);
          
          const cellSize = Math.floor((strength / 10) * 30) + 10; // Use strength
          
          for (let y = 0; y < height; y += cellSize) {
            for (let x = 0; x < width; x += cellSize) {
              const sampleX = Math.min(x + Math.floor(Math.random() * cellSize), width - 1);
              const sampleY = Math.min(y + Math.floor(Math.random() * cellSize), height - 1);
              
              const imageData = tempCtx.getImageData(sampleX, sampleY, 1, 1);
              const pixel = imageData.data;
              
              ctx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
              
              const points = Math.floor(Math.random() * 4) + 4;
              ctx.beginPath();
              for (let i = 0; i < points; i++) {
                const angle = (Math.PI * 2 * i) / points + Math.random() * 0.5;
                const radius = cellSize * (Math.random() * 0.5 + 0.5);
                const px = x + cellSize / 2 + Math.cos(angle) * radius;
                const py = y + cellSize / 2 + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
              }
              ctx.closePath();
              ctx.fill();
            }
          }
        };

        const applyEmboss = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newData = new Uint8ClampedArray(data);
          
          const kernel = [
            [-2, -1, 0],
            [-1,  1, 1],
            [ 0,  1, 2]
          ];
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              let r = 0, g = 0, b = 0;
              
              for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                  const idx = ((y + ky) * width + (x + kx)) * 4;
                  const weight = kernel[ky + 1][kx + 1];
                  r += data[idx] * weight;
                  g += data[idx + 1] * weight;
                  b += data[idx + 2] * weight;
                }
              }
              
              const i = (y * width + x) * 4;
              newData[i] = Math.max(20, Math.min(235, r + 128));
              newData[i + 1] = Math.max(20, Math.min(235, g + 128));
              newData[i + 2] = Math.max(20, Math.min(235, b + 128));
            }
          }
          
          const newImageData = ctx.createImageData(width, height);
          newImageData.data.set(newData);
          ctx.putImageData(newImageData, 0, 0);
        };

        const applySolarize = (imageData, strength = 5) => {
          const data = imageData.data;
          const threshold = 255 - (strength / 10) * 155;
          
          for (let i = 0; i < data.length; i += 4) {
            if (data[i] > threshold) data[i] = 255 - data[i];
            if (data[i + 1] > threshold) data[i + 1] = 255 - data[i + 1];
            if (data[i + 2] > threshold) data[i + 2] = 255 - data[i + 2];
          }
        };

        const applyRipple = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const amplitude = (strength / 10) * 60 + 20; // 20-80px (increased from 10-30)
          const frequency = (strength / 10) * 0.02 + 0.01; // 0.01-0.03 (slower ripples)
          const waveType = Math.random() > 0.5;
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              let offsetX, offsetY;
              
              if (waveType) {
                offsetX = Math.sin(y * frequency) * amplitude;
                offsetY = Math.cos(x * frequency) * amplitude;
              } else {
                const distance = Math.sqrt(Math.pow(x - width / 2, 2) + Math.pow(y - height / 2, 2));
                offsetX = Math.sin(distance * frequency) * amplitude;
                offsetY = Math.cos(distance * frequency) * amplitude;
              }
              
              const srcX = Math.floor(x + offsetX);
              const srcY = Math.floor(y + offsetY);
              const destIdx = (y * width + x) * 4;
              
              if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                const srcIdx = (srcY * width + srcX) * 4;
                
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              } else {
                // Keep original pixel when ripple goes out of bounds
                const origIdx = (y * width + x) * 4;
                newData[destIdx] = data[origIdx];
                newData[destIdx + 1] = data[origIdx + 1];
                newData[destIdx + 2] = data[origIdx + 2];
                newData[destIdx + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyBurn = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          const centerX = width / 2;
          const centerY = height / 2;
          const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
          const burnIntensity = (strength / 10) * 0.8; // 0-0.8 based on strength
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = (y * width + x) * 4;
              
              // Calculate distance from center (normalized)
              const dx = x - centerX;
              const dy = y - centerY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const normalizedDist = distance / maxDist;
              
              // Create burn gradient from edges
              const burnAmount = Math.pow(normalizedDist, 1.5) * burnIntensity;
              
              let r = data[i];
              let g = data[i + 1];
              let b = data[i + 2];
              
              // Darken and add orange/brown tones
              r = r * (1 - burnAmount * 0.7) + burnAmount * 120; // Add orange
              g = g * (1 - burnAmount * 0.8) + burnAmount * 40;  // Reduce green
              b = b * (1 - burnAmount * 0.9);                     // Reduce blue heavily
              
              // Add some random "char" spots
              if (Math.random() < burnAmount * 0.3) {
                r *= 0.3;
                g *= 0.2;
                b *= 0.1;
              }
              
              data[i] = Math.max(20, Math.min(235, r));
              data[i + 1] = Math.max(20, Math.min(235, g));
              data[i + 2] = Math.max(20, Math.min(235, b));
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
        };

        const applyExplosion = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const centerX = width / 2;
          const centerY = height / 2;
          const maxDisplacement = (strength / 10) * 25 + 5; // 5-30px based on strength
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              // Calculate direction from center
              const dx = x - centerX;
              const dy = y - centerY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const angle = Math.atan2(dy, dx);
              
              // Add random angular offset for irregular displacement
              const angleOffset = (Math.random() - 0.5) * Math.PI * 0.3;
              const finalAngle = angle + angleOffset;
              
              // Displacement decreases with distance from center (explosion epicenter)
              const distanceFactor = Math.min(distance / (Math.max(width, height) / 2), 1);
              const displacement = (Math.random() * 0.7 + 0.3) * maxDisplacement * (1 - distanceFactor * 0.3);
              
              // Calculate source position (opposite direction for explosion effect)
              const srcX = Math.floor(x - Math.cos(finalAngle) * displacement);
              const srcY = Math.floor(y - Math.sin(finalAngle) * displacement);
              
              if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                const srcIdx = (srcY * width + srcX) * 4;
                const destIdx = (y * width + x) * 4;
                
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              } else {
                const destIdx = (y * width + x) * 4;
                const srcIdx = (y * width + x) * 4;
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyMosaic = (ctx, width, height, strength = 5) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          ctx.clearRect(0, 0, width, height);
          
          const tiles = Math.floor((strength / 10) * 3) + 2; // Use strength
          const tileWidth = width / tiles;
          const tileHeight = height / tiles;
          
          for (let ty = 0; ty < tiles; ty++) {
            for (let tx = 0; tx < tiles; tx++) {
              const flip = Math.random() > 0.5;
              const rotate = Math.floor(Math.random() * 4) * 90;
              
              ctx.save();
              ctx.translate(tx * tileWidth + tileWidth / 2, ty * tileHeight + tileHeight / 2);
              ctx.rotate((rotate * Math.PI) / 180);
              if (flip) ctx.scale(-1, 1);
              ctx.drawImage(tempCanvas, -tileWidth / 2, -tileHeight / 2, tileWidth, tileHeight);
              ctx.restore();
            }
          }
        };

        const applyDisplacement = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const displacementStrength = Math.floor((strength / 10) * 30) + 10; // FIXED: renamed variable
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = (y * width + x) * 4;
              
              const displaceX = ((data[i] / 255) - 0.5) * displacementStrength;
              const displaceY = ((data[i + 1] / 255) - 0.5) * displacementStrength;
              
              const srcX = Math.floor(x + displaceX);
              const srcY = Math.floor(y + displaceY);
              
              if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                const srcIdx = (srcY * width + srcX) * 4;
                newData[i] = data[srcIdx];
                newData[i + 1] = data[srcIdx + 1];
                newData[i + 2] = data[srcIdx + 2];
                newData[i + 3] = 255;
              }
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyChunkyBlocks = (ctx, width, height, strength = 5) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          const chunkCount = Math.floor((strength / 10) * 50) + 20; // Use strength
          
          for (let i = 0; i < chunkCount; i++) {
            const chunkWidth = Math.floor((strength / 10) * 120) + 5;
            const chunkHeight = Math.floor((strength / 10) * 100) + 5;
            
            const srcX = Math.floor(Math.random() * Math.max(1, width - chunkWidth));
            const srcY = Math.floor(Math.random() * Math.max(1, height - chunkHeight));
            
            const destX = Math.floor(Math.random() * width);
            const destY = Math.floor(Math.random() * height);
            
            ctx.globalAlpha = Math.random() * 0.5 + 0.5;
            ctx.drawImage(tempCanvas, srcX, srcY, chunkWidth, chunkHeight, destX, destY, chunkWidth, chunkHeight);
          }
          ctx.globalAlpha = 1.0;
        };

        const applyParticles = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          const particleCount = Math.floor((strength / 10) * 800) + 300; // Use strength
          
          for (let i = 0; i < particleCount; i++) {
            const x = Math.floor(Math.random() * width);
            const y = Math.floor(Math.random() * height);
            
            const sizeType = Math.random();
            let size;
            if (sizeType < 0.5) {
              size = Math.floor((strength / 10) * 3) + 1;
            } else if (sizeType < 0.8) {
              size = Math.floor((strength / 10) * 10) + 2;
            } else {
              size = Math.floor((strength / 10) * 20) + 5;
            }
            
            const sampleX = Math.floor(x + (Math.random() - 0.5) * 50);
            const sampleY = Math.floor(y + (Math.random() - 0.5) * 50);
            
            if (sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < height) {
              const sampleIdx = (sampleY * width + sampleX) * 4;
              ctx.fillStyle = `rgba(${data[sampleIdx]}, ${data[sampleIdx + 1]}, ${data[sampleIdx + 2]}, ${Math.random() * 0.5 + 0.5})`;
              
              if (Math.random() > 0.7) {
                ctx.fillRect(x, y, size, size * (Math.random() * 2 + 0.5));
              } else {
                ctx.fillRect(x, y, size, size);
              }
            }
          }
        };

        const applySliceShift = (ctx, width, height, strength = 5) => {
          const sliceCount = Math.floor((strength / 10) * 20) + 10; // Use strength
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          for (let i = 0; i < sliceCount; i++) {
            const sliceHeight = Math.floor((strength / 10) * 30) + 3;
            const y = Math.floor(Math.random() * Math.max(1, height - sliceHeight));
            const shift = (Math.random() - 0.5) * width * ((strength / 10) * 0.3);
            
            const sliceData = tempCtx.getImageData(0, y, width, sliceHeight);
            ctx.putImageData(sliceData, shift, y);
          }
        };

        const applyLiquify = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const waveCount = Math.floor((strength / 10) * 3) + 2;
          
          // Copy all original data first as fallback
          newData.set(data);
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              let offsetX = 0;
              let offsetY = 0;
              
              for (let w = 0; w < waveCount; w++) {
                const freq = Math.random() * 0.05 + 0.01;
                const amp = (strength / 10) * 20 + 5;
                offsetX += Math.sin((y + w * 100) * freq) * amp;
                offsetY += Math.cos((x + w * 100) * freq) * amp;
              }
              
              const srcX = Math.floor(x + offsetX);
              const srcY = Math.floor(y + offsetY);
              
              if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                const srcIdx = (srcY * width + srcX) * 4;
                const destIdx = (y * width + x) * 4;
                
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = 255;
              }
              // Otherwise keeps original pixel from newData.set(data)
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyWaveDistortion = (ctx, width, height, strength = 5) => {
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          const newImageData = ctx.createImageData(width, height);
          const newData = newImageData.data;
          
          const amplitude = (strength / 10) * 60 + 20; // 20-80px (increased from 5-20)
          const frequency = (strength / 10) * 0.02 + 0.005; // 0.005-0.025 (slower waves)
          
          // First, copy all original data as fallback
          newData.set(data);
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const offsetX = Math.sin(y * frequency) * amplitude;
              const offsetY = Math.cos(x * frequency) * amplitude;
              
              const srcX = Math.floor(x + offsetX);
              const srcY = Math.floor(y + offsetY);
              
              if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                const srcIdx = (srcY * width + srcX) * 4;
                const destIdx = (y * width + x) * 4;
                
                newData[destIdx] = data[srcIdx];
                newData[destIdx + 1] = data[srcIdx + 1];
                newData[destIdx + 2] = data[srcIdx + 2];
                newData[destIdx + 3] = data[srcIdx + 3];
              }
              // If out of bounds, newData already has the original pixel from newData.set(data)
            }
          }
          
          ctx.putImageData(newImageData, 0, 0);
        };

        const applyDeepFry = (imageData, strength = 5) => {
          const data = imageData.data;
          const contrast = 1 + (strength / 10) * 0.3;
          const saturation = 1 + (strength / 10) * 0.8;
          
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            r = ((r / 255 - 0.5) * contrast + 0.5) * 255;
            g = ((g / 255 - 0.5) * contrast + 0.5) * 255;
            b = ((b / 255 - 0.5) * contrast + 0.5) * 255;
            
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            r = gray + (r - gray) * saturation;
            g = gray + (g - gray) * saturation;
            b = gray + (b - gray) * saturation;
            
            data[i] = Math.max(15, Math.min(240, r));
            data[i + 1] = Math.max(15, Math.min(240, g));
            data[i + 2] = Math.max(15, Math.min(240, b));
          }
        };

        const applyChannelSwap = (imageData, strength = 5) => {
          const data = imageData.data;
          const swapType = Math.floor((strength / 10) * 6);
          
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            switch (swapType) {
              case 0:
                data[i] = g; data[i + 1] = b; data[i + 2] = r;
                break;
              case 1:
                data[i] = b; data[i + 1] = r; data[i + 2] = g;
                break;
              case 2:
                data[i] = r; data[i + 1] = b; data[i + 2] = g;
                break;
              case 3:
                data[i] = g; data[i + 1] = r; data[i + 2] = b;
                break;
              case 4:
                data[i] = b; data[i + 1] = g; data[i + 2] = r;
                break;
              default:
                break;
            }
          }
        };

        const applyJPEGCorruption = (ctx, width, height) => {
          const quality = Math.random() * 0.2 + 0.2;
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = width;
          tempCanvas.height = height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(ctx.canvas, 0, 0);
          
          const dataURL = tempCanvas.toDataURL('image/jpeg', quality);
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, 0, 0);
          };
          img.src = dataURL;
        };

        const addOverlay = () => {
          if (!currentImage) return;
          
          setIsProcessing(true);
          
          setTimeout(() => {
            const canvas = canvasRef.current;
            const ctx = getContext(canvas); // Use helper
            const width = canvas.width;
            const height = canvas.height;
            
            const currentState = canvas.toDataURL();
            // Keep only last 2 states for undo
            setHistory(prev => {
              const newHistory = [...prev, currentState];
              return newHistory.slice(-2); // Keep only last 2
            });
            
            const scaledWidth = width * 0.7;
            const scaledHeight = height * 0.7;
            
            const x = Math.random() * (width - scaledWidth);
            const y = Math.random() * (height - scaledHeight);
            
            const rotation = (Math.random() - 0.5) * Math.PI;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(canvas, 0, 0);
            
            ctx.save();
            ctx.translate(x + scaledWidth / 2, y + scaledHeight / 2);
            ctx.rotate(rotation);
            ctx.globalAlpha = 0.5;
            ctx.drawImage(tempCanvas, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
            ctx.restore();
            
            setLastEffects(['Add Overlay (70% size, 50% opacity)']);
            setNukeCount(prev => prev + 1);
            setIsProcessing(false);
          }, 100);
        };

        const applyPattern = () => {
          if (!currentImage) return;
          
          setIsProcessing(true);
          setHasProtectedData(false); // â† ADD THIS LINE - image is now altered!

          const canvas = canvasRef.current;
          const ctx = getContext(canvas); // Use helper
          const width = canvas.width;
          const height = canvas.height;
          
          const currentState = canvas.toDataURL();
          // Keep only last 2 states for undo
          setHistory(prev => {
            const newHistory = [...prev, currentState];
            return newHistory.slice(-2); // Keep only last 2
          });
          
          // Choose a pattern type
          const patternType = Math.floor(Math.random() * 6);
          const patternNames = [
            'Mirror Quad', 
            'Diagonal Mirror', 
            'Offset Grid', 
            'Checkerboard Flip',
            'Spiral Arrangement',
            'Fractal Recursion'
          ];
          
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(canvas, 0, 0);
          
          // IMPORTANT: Keep original image as base for all patterns
          // Patterns will blend on top
          
          switch(patternType) {
            case 0: // Mirror Quad - 4 mirrored quadrants
              {
                const halfW = width / 2;
                const halfH = height / 2;
                
                // Draw original first (already on canvas)
                // Now overlay with mirrored quadrants at reduced opacity
                ctx.globalAlpha = 0.6;
                
                // Top-left (original)
                ctx.drawImage(tempCanvas, 0, 0, halfW, halfH, 0, 0, halfW, halfH);
                
                // Top-right (horizontal flip)
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(tempCanvas, 0, 0, halfW, halfH, -width, 0, halfW, halfH);
                ctx.restore();
                
                // Bottom-left (vertical flip)
                ctx.save();
                ctx.scale(1, -1);
                ctx.drawImage(tempCanvas, 0, 0, halfW, halfH, 0, -height, halfW, halfH);
                ctx.restore();
                
                // Bottom-right (both flips)
                ctx.save();
                ctx.scale(-1, -1);
                ctx.drawImage(tempCanvas, 0, 0, halfW, halfH, -width, -height, halfW, halfH);
                ctx.restore();
                
                ctx.globalAlpha = 1.0;
              }
              break;
              
            case 1: // Diagonal Mirror
              {
                // Original already on canvas
                
                // Mirror along diagonal with blending
                ctx.globalAlpha = 0.5;
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(Math.PI / 2);
                ctx.scale(-1, 1);
                ctx.drawImage(tempCanvas, -width / 2, -height / 2);
                ctx.restore();
                ctx.globalAlpha = 1.0;
              }
              break;
              
            case 2: // Offset Grid - datamosh style
              {
                // Original already on canvas as base
                const gridSize = Math.floor(Math.random() * 3) + 3; // 3-5
                const cellW = width / gridSize;
                const cellH = height / gridSize;
                const maxShift = Math.min(cellW, cellH) * 0.3; // Reduced shift to avoid gaps
                
                ctx.globalAlpha = 0.7;
                
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const srcX = col * cellW;
                    const srcY = row * cellH;
                    const offsetX = (Math.random() - 0.5) * maxShift;
                    const offsetY = (Math.random() - 0.5) * maxShift;
                    
                    // Only shift some cells randomly
                    if (Math.random() > 0.3) {
                      ctx.drawImage(tempCanvas, 
                        srcX, srcY, cellW, cellH,
                        srcX + offsetX, srcY + offsetY, cellW, cellH);
                    }
                  }
                }
                
                ctx.globalAlpha = 1.0;
              }
              break;
              
            case 3: // Checkerboard Flip
              {
                // Original already on canvas
                const gridSize = Math.floor(Math.random() * 2) + 4; // 4-5
                const cellW = width / gridSize;
                const cellH = height / gridSize;
                
                ctx.globalAlpha = 0.65;
                
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    // Skip some cells to show original underneath
                    if ((row + col) % 3 === 0) continue;
                    
                    const flipH = (row + col) % 2 === 0;
                    const flipV = Math.random() > 0.5;
                    
                    ctx.save();
                    ctx.translate(col * cellW + cellW / 2, row * cellH + cellH / 2);
                    ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                    ctx.drawImage(tempCanvas, 
                      col * cellW, row * cellH, cellW, cellH,
                      -cellW / 2, -cellH / 2, cellW, cellH);
                    ctx.restore();
                  }
                }
                
                ctx.globalAlpha = 1.0;
              }
              break;
              
            case 4: // Spiral Arrangement
              {
                // Original already on canvas as base
                const centerX = width / 2;
                const centerY = height / 2;
                const copies = 8 + Math.floor(Math.random() * 4); // 8-11
                const maxRadius = Math.min(width, height) * 0.4;
                
                ctx.globalAlpha = 0.5;
                
                for (let i = 0; i < copies; i++) {
                  const angle = (i / copies) * Math.PI * 4; // 2 full spirals
                  const radius = (i / copies) * maxRadius;
                  const x = centerX + Math.cos(angle) * radius;
                  const y = centerY + Math.sin(angle) * radius;
                  const scale = 0.25 + (i / copies) * 0.25; // 0.25 to 0.5
                  
                  ctx.save();
                  ctx.translate(x, y);
                  ctx.rotate(angle);
                  ctx.scale(scale, scale);
                  ctx.drawImage(tempCanvas, -width / 2, -height / 2);
                  ctx.restore();
                }
                
                ctx.globalAlpha = 1.0;
              }
              break;
              
            case 5: // Fractal Recursion
              {
                // Original already on canvas
                const levels = 3;
                const scale = 0.5;
                
                function drawRecursive(level, x, y, w, h, angle, alpha) {
                  if (level === 0) return;
                  
                  ctx.save();
                  ctx.globalAlpha = alpha;
                  ctx.translate(x, y);
                  ctx.rotate(angle);
                  ctx.drawImage(tempCanvas, -w / 2, -h / 2, w, h);
                  ctx.restore();
                  
                  // Draw 4 smaller copies at corners
                  const newW = w * scale;
                  const newH = h * scale;
                  const offset = w * 0.3;
                  const newAlpha = alpha * 0.7; // Fade out as we go deeper
                  
                  drawRecursive(level - 1, x - offset, y - offset, newW, newH, angle + 0.1, newAlpha);
                  drawRecursive(level - 1, x + offset, y - offset, newW, newH, angle - 0.1, newAlpha);
                  drawRecursive(level - 1, x - offset, y + offset, newW, newH, angle - 0.1, newAlpha);
                  drawRecursive(level - 1, x + offset, y + offset, newW, newH, angle + 0.1, newAlpha);
                }
                
                // Draw recursion on top of original
                drawRecursive(levels, width / 2, height / 2, width * 0.8, height * 0.8, 0, 0.6);
                ctx.globalAlpha = 1.0;
              }
              break;
          }
          
          setLastEffects([patternNames[patternType]]);
          setNukeCount(prev => prev + 1);
          setIsProcessing(false);
        };

        // Embed data into image using LSB steganography
        const embedDataInImage = (canvas, data, password) => {
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imageData.data;
          
          // Encrypt the data
          const encrypted = CryptoJS.AES.encrypt(data, password).toString();
          
          // Add length header (first 32 bits = data length)
          const dataLength = encrypted.length;
          const fullData = dataLength.toString().padStart(10, '0') + encrypted;
          
          // Convert to binary
          let binaryData = '';
          for (let i = 0; i < fullData.length; i++) {
            binaryData += fullData.charCodeAt(i).toString(2).padStart(8, '0');
          }
          
          // Check if we have enough space
          const maxBits = (pixels.length / 4) * 3; // RGB channels only, not alpha
          if (binaryData.length > maxBits) {
            throw new Error('Image too small to embed data');
          }
          
          // Embed bits into LSB of RGB channels
          let bitIndex = 0;
          for (let i = 0; i < pixels.length && bitIndex < binaryData.length; i += 4) {
            // Embed in R, G, B (skip alpha)
            for (let channel = 0; channel < 3 && bitIndex < binaryData.length; channel++) {
              const bit = parseInt(binaryData[bitIndex]);
              pixels[i + channel] = (pixels[i + channel] & 0xFE) | bit; // Clear LSB and set new bit
              bitIndex++;
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
          return canvas;
        };

        // Extract data from image using LSB steganography
        const extractDataFromImage = (canvas, password) => {
          const ctx = canvas.getContext('2d');
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imageData.data;
          
          // Extract length header (first 80 bits = 10 characters)
          let binaryLength = '';
          for (let i = 0; i < 80; i++) {
            const pixelIndex = Math.floor(i / 3) * 4;
            const channel = i % 3;
            binaryLength += (pixels[pixelIndex + channel] & 1).toString();
          }
          
          // Convert binary to length
          let lengthStr = '';
          for (let i = 0; i < binaryLength.length; i += 8) {
            lengthStr += String.fromCharCode(parseInt(binaryLength.substr(i, 8), 2));
          }
          const dataLength = parseInt(lengthStr);
          
          if (isNaN(dataLength) || dataLength <= 0) {
            throw new Error('No hidden data found in image');
          }
          
          // Extract encrypted data
          const totalBits = (dataLength * 8) + 80; // +80 for the length header
          let binaryData = '';
          
          for (let i = 80; i < totalBits && i < pixels.length * 3 / 4; i++) {
            const pixelIndex = Math.floor(i / 3) * 4;
            const channel = i % 3;
            binaryData += (pixels[pixelIndex + channel] & 1).toString();
          }
          
          // Convert binary to string
          let encrypted = '';
          for (let i = 0; i < binaryData.length; i += 8) {
            encrypted += String.fromCharCode(parseInt(binaryData.substr(i, 8), 2));
          }
          
          // Decrypt
          try {
            const decrypted = CryptoJS.AES.decrypt(encrypted, password);
            const original = decrypted.toString(CryptoJS.enc.Utf8);
            
            if (!original) {
              throw new Error('Invalid password');
            }
            
            return original;
          } catch (e) {
            throw new Error('Invalid password or corrupted data');
          }
        };

        const nukeImage = () => {
          if (!currentImage) return;
          
          setIsProcessing(true);
          setHasProtectedData(false);
          
          // Small delay to show loading state
          setTimeout(() => {
            const canvas = canvasRef.current;
            const ctx = getContext(canvas);
            const width = canvas.width;
            const height = canvas.height;
            
            const currentState = canvas.toDataURL();
            // Keep only last 2 states for undo
            setHistory(prev => {
              const newHistory = [...prev, currentState];
              return newHistory.slice(-2); // Keep only last 2
            });
            
            const strength = Math.floor(Math.random() * 10) + 1;
            
            const numEffects = Math.floor(Math.random() * 2) + 1;
            const allEffects = [
              { fn: () => applyRGBShift(ctx, width, height, strength), name: 'RGB Shift' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyGlitchEffect(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Glitch Effect' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyNoise(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Noise' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyColorDistortion(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Color Distortion' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyPosterize(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Posterize' },
              { fn: () => applyEdgeDetection(ctx, width, height, strength), name: 'Edge Detection' },
              { fn: () => applyKaleidoscope(ctx, width, height, strength), name: 'Kaleidoscope' },
              { fn: () => applyWaveDistortion(ctx, width, height, strength), name: 'Wave Distortion' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyDeepFry(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Deep Fry' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applyChannelSwap(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Channel Swap' },
              { fn: () => applyBlockGlitch(ctx, width, height, strength), name: 'Block Glitch' },
              { fn: () => applyChromatic(ctx, width, height, strength), name: 'Chromatic Aberration' },
              { fn: () => applyRadialBlur(ctx, width, height, strength), name: 'Radial Blur' },
              { fn: () => applySwirl(ctx, width, height, strength), name: 'Swirl' },
              { fn: () => applyBurn(ctx, width, height, strength), name: 'Burn' },
              { fn: () => applyExplosion(ctx, width, height, strength), name: 'Explosion' },
              { fn: () => applyDisplacement(ctx, width, height, strength), name: 'Displacement' },
              { fn: () => applyParticles(ctx, width, height, strength), name: 'Particles' },
              { fn: () => applyLiquify(ctx, width, height, strength), name: 'Liquify' },
              { fn: () => applyChunkyBlocks(ctx, width, height, strength), name: 'Chunky Blocks' },
              { fn: () => applySliceShift(ctx, width, height, strength), name: 'Slice Shift' },
              { fn: () => applyGlass(ctx, width, height, strength), name: 'Glass' },
              { fn: () => applyBulge(ctx, width, height, strength), name: 'Bulge' },
              { fn: () => applyEmboss(ctx, width, height, strength), name: 'Emboss' },
              { fn: () => {
                const imageData = ctx.getImageData(0, 0, width, height);
                applySolarize(imageData, strength);
                ctx.putImageData(imageData, 0, 0);
              }, name: 'Solarize' },
              { fn: () => applyRipple(ctx, width, height, strength), name: 'Ripple' },
            ];
            
            const shuffled = allEffects.sort(() => Math.random() - 0.5);
            const selectedEffects = shuffled.slice(0, numEffects);
            
            selectedEffects.forEach(effect => effect.fn());
            
            const effectNames = selectedEffects.map(e => `${e.name} (${strength})`);
            
            if (Math.random() > 0.85) {
              applyJPEGCorruption(ctx, width, height);
              effectNames.push('JPEG Corruption');
            }
            
            setLastEffects(effectNames);
            setNukeCount(prev => prev + 1);
            setIsProcessing(false);
          }, 100);
        };

        const undoNuke = () => {
          if (history.length === 0) return;
          
          setIsProcessing(true);
          
          setTimeout(() => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            
            const previousState = history[history.length - 1];
            
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, 0, 0);
              setHistory(prev => prev.slice(0, -1));
              setNukeCount(prev => Math.max(0, prev - 1));
              setLastEffects([]);
              
              // â† ADD THIS SECTION: Re-check for protected data after undo
              setTimeout(() => {
                try {
                  const tempCanvas = document.createElement('canvas');
                  tempCanvas.width = canvas.width;
                  tempCanvas.height = canvas.height;
                  const tempCtx = tempCanvas.getContext('2d');
                  tempCtx.drawImage(canvas, 0, 0);
                  
                  // Try to read length header
                  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                  const pixels = imageData.data;
                  
                  let binaryLength = '';
                  for (let i = 0; i < 80; i++) {
                    const pixelIndex = Math.floor(i / 3) * 4;
                    const channel = i % 3;
                    binaryLength += (pixels[pixelIndex + channel] & 1).toString();
                  }
                  
                  let lengthStr = '';
                  for (let i = 0; i < binaryLength.length; i += 8) {
                    lengthStr += String.fromCharCode(parseInt(binaryLength.substr(i, 8), 2));
                  }
                  const dataLength = parseInt(lengthStr);
                  
                  // If valid length found, image has protected data
                  if (!isNaN(dataLength) && dataLength > 0 && dataLength < 10000000) {
                    setHasProtectedData(true);
                    console.log('ðŸ” Protected data detected after undo!');
                  } else {
                    setHasProtectedData(false);
                  }
                } catch (e) {
                  setHasProtectedData(false);
                }
              }, 100);
              // â† END OF NEW SECTION
              
              setIsProcessing(false);
              showToast('âª Undone!', 'info');
            };
            img.src = previousState;
          }, 50);
        };

        const exportImage = async (withPassword = false) => {
          if (!canvasRef.current) return;
          
          if (withPassword) {
            setExportMode('protected');
            setShowPasswordModal(true);
            return;
          }
          
          // Normal export (existing code)
          const canvas = canvasRef.current;
          const filename = `nuked-meme-${nukeCount}.png`;
          
          const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          const canShare = navigator.share && navigator.canShare;
          
          if (isMobile && canShare) {
            try {
              canvas.toBlob(async (blob) => {
                const file = new File([blob], filename, { type: 'image/png' });
                
                if (navigator.canShare({ files: [file] })) {
                  await navigator.share({
                    files: [file],
                    title: 'Nuked Meme',
                    text: 'Check out my nuked meme!'
                  });
                  showToast('ðŸ“± Image shared!', 'success');
                } else {
                  downloadImage(canvas, filename);
                }
              }, 'image/png');
            } catch (error) {
              if (error.name !== 'AbortError') {
                console.error('Share failed:', error);
                downloadImage(canvas, filename);
              }
            }
          } else {
            downloadImage(canvas, filename);
          }
        };

        const downloadImage = (canvas, filename) => {
          const link = document.createElement('a');
          link.download = filename;
          link.href = canvas.toDataURL('image/png');
          link.click();
          showToast(`ðŸ’¾ Exported: ${filename}`, 'success');
        };


        const handleProtectedExport = () => {
          if (!password || password.length < 4) {
            showToast('âš ï¸ Password must be at least 4 characters', 'warning');
            return;
          }
          
          try {
            setIsProcessing(true);
            
            // Create a temporary canvas with the nuked image
            const tempCanvas = document.createElement('canvas');
            const nukedCanvas = canvasRef.current;
            tempCanvas.width = nukedCanvas.width;
            tempCanvas.height = nukedCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(nukedCanvas, 0, 0);
            
            // Compress and encode original image
            const originalCanvas = document.createElement('canvas');
            const originalCtx = originalCanvas.getContext('2d');
            
            // Scale down to reduce size (max 800px)
            const maxSize = 800;
            let width = currentImage.width;
            let height = currentImage.height;
            
            if (width > maxSize || height > maxSize) {
              if (width > height) {
                height = (height / width) * maxSize;
                width = maxSize;
              } else {
                width = (width / height) * maxSize;
                height = maxSize;
              }
            }
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            originalCtx.drawImage(currentImage, 0, 0, width, height);
            
            // Convert to compressed base64
            const originalData = originalCanvas.toDataURL('image/jpeg', 0.7);
            
            // Embed in nuked image
            embedDataInImage(tempCanvas, originalData, password);
            
            // Download
            const link = document.createElement('a');
            link.download = `protected-meme-${nukeCount}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
            
            showToast('ðŸ” Protected image exported!', 'success');
            setShowPasswordModal(false);
            setPassword('');
            setShowPassword(false);
            setLastTypedIndex(-1);
            setIsProcessing(false);
          } catch (error) {
            console.error('Export failed:', error);
            showToast('âŒ Export failed: ' + error.message, 'warning');
            setIsProcessing(false);
          }
        };

        const handlePasswordChange = (e) => {
          const displayValue = e.target.value;          
          // Calculate the actual password by tracking what changed
          let newPassword = password;
          
          if (displayValue.length > password.length) {
            // Characters were added - get only the new characters
            const addedChars = displayValue.slice(password.length);
            newPassword = password + addedChars.replace(/â€¢/g, '');
          } else if (displayValue.length < password.length) {
            // Characters were deleted
            newPassword = password.slice(0, displayValue.length);
          }
          
          setPassword(newPassword);
          
          if (!showPassword && newPassword.length > 0) {
            setLastTypedIndex(newPassword.length - 1);
            
          }
        };

        const togglePasswordVisibility = () => {
          const newShowPassword = !showPassword;
          setShowPassword(newShowPassword);
          setLastTypedIndex(-1);
        };

        const getPasswordDisplayValue = () => {          
          if (showPassword) {
            return password;
          }
          
          if (password.length === 0) {
            return '';
          }
          
          const display = password.split('').map((char, index) => {
            return index === lastTypedIndex ? char : 'â€¢';
          }).join('');          
          return display;
        };

        const handleRestoreImage = () => {
          if (!password || password.length < 4) {
            showToast('âš ï¸ Password must be at least 4 characters', 'warning');
            return;
          }
          
          if (!currentImage) {
            showToast('âš ï¸ No image loaded', 'warning');
            return;
          }
          
          try {
            setIsProcessing(true);
            
            // Use the already loaded canvas
            const canvas = canvasRef.current;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            
            // Extract hidden data
            const originalData = extractDataFromImage(tempCanvas, password);
            
            // Load the original image
            const originalImg = new Image();
            originalImg.onload = () => {
              setCurrentImage(originalImg);
              setNukeCount(0);
              setHistory([]);
              setLastEffects([]);
              setHasProtectedData(false); // Hide restore button after restoring
              drawImageToCanvas(originalImg);
              
              showToast('âœ… Original image restored!', 'success');
              setShowRestoreModal(false);
              setPassword('');
              setShowPassword(false);
              setLastTypedIndex(-1);
              setIsProcessing(false);
            };
            originalImg.onerror = () => {
              showToast('âŒ Failed to load restored image', 'warning');
              setIsProcessing(false);
            };
            originalImg.src = originalData;
            
          } catch (error) {
            console.error('Restore failed:', error);
            showToast('âŒ ' + error.message, 'warning');
            setIsProcessing(false);
          }
        };

        const resetImage = () => {
          setCurrentImage(null);
          setNukeCount(0);
          setHistory([]);
          setLastEffects([]);
          setHasProtectedData(false);
          setPassword('');
          setShowPassword(false);
          setLastTypedIndex(-1);
          fileInputRef.current?.click();
        };

        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-900 via-pink-900 to-red-900 p-8">
            <div className="max-w-4xl mx-auto">
              <div className="text-center mb-8">
                <h1 className="text-6xl font-black text-white mb-2 drop-shadow-lg" style={{
                  textShadow: '0 0 20px rgba(255,0,255,0.8), 0 0 40px rgba(255,0,0,0.6)'
                }}>
                  ðŸ”¥ NUKE MEMES ðŸ”¥
                </h1>
                <p className="text-xl text-pink-200">Deep fry your memes into oblivion</p>
                {nukeCount > 0 && (
                  <div className="mt-4 inline-block bg-yellow-400 text-black px-6 py-2 rounded-full font-bold text-lg">
                    ðŸ’¥ NUKES: {nukeCount} ðŸ’¥
                  </div>
                )}
              </div>

              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                onChange={(e) => e.target.files[0] && loadImage(e.target.files[0])}
                className="hidden"
              />

              {!currentImage ? (
                <div
                  onClick={() => fileInputRef.current.click()}
                  className="border-4 border-dashed border-pink-400 rounded-lg p-16 text-center cursor-pointer hover:border-pink-300 hover:bg-pink-900/20 transition-all"
                >
                  <div className="text-6xl mb-4">ðŸ“¤</div>
                  <p className="text-2xl text-white font-bold mb-2">Click to Upload Image</p>
                  <p className="text-pink-300">Drop your meme here to start nuking</p>
                </div>
              ) : (
                <>
                  <div className="bg-black rounded-lg p-4 mb-6 shadow-2xl relative">
                    <canvas
                      ref={canvasRef}
                      className="max-w-full mx-auto"
                      style={{ imageRendering: 'pixelated', 
                        imageRendering: '-moz-crisp-edges',
                        imageRendering: 'crisp-edges' }}
                    />
                    {isProcessing && (
                      <div className="absolute inset-0 flex items-center justify-center bg-black/50 rounded-lg">
                        <div className="text-center">
                          <div className="inline-block animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-pink-500 mb-3"></div>
                          <p className="text-white text-xl font-bold animate-pulse">NUKING...</p>
                        </div>
                      </div>
                    )}

                  </div>

                  {toast.show && (
                    <div className="fixed top-8 right-8 z-50 animate-slide-in">
                      <div className={`rounded-lg px-6 py-4 shadow-2xl flex items-center gap-3 ${
                        toast.type === 'success' ? 'bg-gradient-to-r from-green-500 to-emerald-500' :
                        toast.type === 'info' ? 'bg-gradient-to-r from-blue-500 to-cyan-500' :
                        'bg-gradient-to-r from-orange-500 to-yellow-500'
                      }`}>
                        <span className="text-white text-lg font-bold">{toast.message}</span>
                      </div>
                    </div>
                  )}


                  <div className="flex gap-4 flex-wrap justify-center">
                    <button
                      onClick={nukeImage}
                      className="px-8 py-4 bg-gradient-to-r from-red-600 to-orange-600 text-white text-2xl font-black rounded-lg hover:from-red-500 hover:to-orange-500 transform hover:scale-105 transition-all shadow-lg"
                      style={{
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                      }}
                    >
                      ðŸ’£ NUKE (D) ðŸ’£
                    </button>

                    <button
                      onClick={undoNuke}
                      disabled={history.length === 0}
                      className={`px-8 py-4 text-white text-xl font-bold rounded-lg transform hover:scale-105 transition-all shadow-lg ${
                        history.length === 0 
                          ? 'bg-gray-600 cursor-not-allowed opacity-50' 
                          : 'bg-gradient-to-r from-yellow-600 to-amber-600 hover:from-yellow-500 hover:to-amber-500'
                      }`}
                    >
                      â†©ï¸ Undo (A) {history.length > 0 && `[${history.length}]`}
                    </button>

                    <button
                      onClick={applyPattern}
                      className="px-8 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 text-white text-xl font-bold rounded-lg hover:from-indigo-500 hover:to-purple-500 transform hover:scale-105 transition-all shadow-lg"
                    >
                      ðŸ”² Pattern (E)
                    </button>

                    <button
                      onClick={() => exportImage(false)}
                      className="px-8 py-4 bg-gradient-to-r from-green-600 to-teal-600 text-white text-xl font-bold rounded-lg hover:from-green-500 hover:to-teal-500 transform hover:scale-105 transition-all shadow-lg"
                    >
                      ðŸ’¾ Export (S)
                    </button>

                    <button
                      onClick={() => exportImage(true)}
                      className="px-8 py-4 bg-gradient-to-r from-emerald-600 to-green-600 text-white text-xl font-bold rounded-lg hover:from-emerald-500 hover:to-green-500 transform hover:scale-105 transition-all shadow-lg"
                    >
                      ðŸ” Protected (G)
                    </button>

                    {hasProtectedData && (
                      <button
                        onClick={() => setShowRestoreModal(true)}
                        className="px-8 py-4 bg-gradient-to-r from-cyan-600 to-blue-600 text-white text-xl font-bold rounded-lg hover:from-cyan-500 hover:to-blue-500 transform hover:scale-105 transition-all shadow-lg animate-pulse"
                      >
                        ðŸ”“ Restore Original
                      </button>
                    )}

                    <button
                      onClick={resetImage}
                      className="px-8 py-4 bg-gradient-to-r from-blue-600 to-indigo-600 text-white text-xl font-bold rounded-lg hover:from-blue-500 hover:to-indigo-500 transform hover:scale-105 transition-all shadow-lg"
                    >
                      ðŸ”„ New (N)
                    </button>
                  </div>

                  {lastEffects.length > 0 && (
                    <div className="mt-6 text-center">
                      <div className="inline-block bg-gradient-to-r from-cyan-500 to-blue-500 rounded-lg px-6 py-3 shadow-lg">
                        <p className="text-white font-bold text-lg mb-1">âš¡ Last Applied Effects:</p>
                        <div className="flex flex-wrap gap-2 justify-center">
                          {lastEffects.map((effect, index) => (
                            <span key={index} className="bg-white/20 backdrop-blur-sm px-3 py-1 rounded-full text-white text-sm font-semibold">
                              {effect}
                            </span>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}
                  <div className="mt-6 text-center text-pink-200">
                    <p className="text-sm">Right-click the image to copy â€¢ Keep nuking for maximum destruction</p>
                  </div>
                </>
              )}

              <div className="mt-12 text-center text-pink-300 text-sm">
                <p>Inspired by r/NukedMemes â€¢ Crank everything to 11 ðŸŽ¸</p>
                <p className="mt-2 text-pink-400">
                  âŒ¨ï¸ Keyboard: <span className="font-bold">D</span>=Nuke â€¢ <span className="font-bold">A</span>=Undo â€¢ <span className="font-bold">E</span>=Pattern â€¢ <span className="font-bold">S</span>=Export â€¢ <span className="font-bold">G</span>=Protected â€¢ <span className="font-bold">N</span>=New
                </p>
              </div>
            </div>

            {/* Password Modal for Protected Export */}
            {showPasswordModal && (
              <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-gradient-to-br from-purple-900 to-pink-900 rounded-lg p-8 max-w-md w-full shadow-2xl border-2 border-pink-500">
                  <h2 className="text-2xl font-bold text-white mb-4">ðŸ” Password Protect</h2>
                  <p className="text-pink-200 mb-4 text-sm">
                    The original image will be hidden inside the nuked version. Only people with the password can restore it!
                  </p>
                  
                  <div className="relative">
                    <input
                      type="text"
                      value={getPasswordDisplayValue()}
                      onChange={handlePasswordChange}
                      placeholder="Enter password (min 4 chars)"
                      className="w-full px-4 py-3 pr-12 rounded-lg bg-black/30 text-white border-2 border-pink-400 focus:border-pink-300 outline-none mb-4 font-mono"
                      onKeyPress={(e) => e.key === 'Enter' && handleProtectedExport()}
                      autoFocus
                    />
                    <button
                      onClick={togglePasswordVisibility}
                      className="absolute right-3 top-3 text-pink-300 hover:text-pink-100 transition-colors"
                      type="button"
                    >
                      {showPassword ? (
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                        </svg>
                      ) : (
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                      )}
                    </button>
                  </div>
                  
                  <div className="flex gap-3">
                    <button
                      onClick={handleProtectedExport}
                      disabled={isProcessing}
                      className="flex-1 px-6 py-3 bg-gradient-to-r from-green-600 to-teal-600 text-white font-bold rounded-lg hover:from-green-500 hover:to-teal-500 disabled:opacity-50"
                    >
                      {isProcessing ? 'Exporting...' : 'ðŸ’¾ Export Protected'}
                    </button>
                    <button
                      onClick={() => {
                        setShowPasswordModal(false);
                        setPassword('');
                        setShowPassword(false);
                        setLastTypedIndex(-1);
                      }}
                      className="px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-500"
                    >
                      Cancel
                    </button>
                  </div>
                  
                  <p className="text-pink-300 text-xs mt-4">
                    âš ï¸ Warning: This is NOT military-grade encryption. Don't use for highly sensitive data!
                  </p>
                </div>
              </div>
            )}

            {/* Password Modal for Restore */}
            {showRestoreModal && (
              <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-gradient-to-br from-purple-900 to-pink-900 rounded-lg p-8 max-w-md w-full shadow-2xl border-2 border-pink-500">
                  <h2 className="text-2xl font-bold text-white mb-4">ðŸ”“ Restore Original</h2>
                  <p className="text-pink-200 mb-4 text-sm">
                    Enter the password to restore the original image from this protected file.
                  </p>
                  
                  <div className="relative">
                    <input
                      type="text"
                      value={getPasswordDisplayValue()}
                      onChange={handlePasswordChange}
                      placeholder="Enter password"
                      className="w-full px-4 py-3 pr-12 rounded-lg bg-black/30 text-white border-2 border-pink-400 focus:border-pink-300 outline-none mb-4 font-mono"
                      onKeyPress={(e) => e.key === 'Enter' && handleRestoreImage()}
                      autoFocus
                    />
                    <button
                      onClick={() => setShowPassword(!showPassword)}
                      className="absolute right-3 top-3 text-pink-300 hover:text-pink-100 transition-colors"
                      type="button"
                    >
                      {showPassword ? (
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                        </svg>
                      ) : (
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                      )}
                    </button>
                  </div>
                  
                  <div className="flex gap-3">
                    <button
                      onClick={handleRestoreImage}
                      disabled={isProcessing}
                      className="flex-1 px-6 py-3 bg-gradient-to-r from-blue-600 to-cyan-600 text-white font-bold rounded-lg hover:from-blue-500 hover:to-cyan-500 disabled:opacity-50"
                    >
                      {isProcessing ? 'Restoring...' : 'ðŸ”“ Restore'}
                    </button>
                    <button
                      onClick={() => {
                        setShowRestoreModal(false);
                        setPassword('');
                        setShowPassword(false);
                        setLastTypedIndex(-1);
                      }}
                      className="px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-500"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
    };

    // Render component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NukeMemes />);
  </script>
</body>
</html>
